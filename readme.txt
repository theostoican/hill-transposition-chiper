README

Fisiere incluse:

matrixCipher.m cominv.m modulor.m decrypt.m transposition.m strassen2.m partition.m myinverse.m pow.m strassen.m readme.txt 

1A
Ideea esentiala in implementarea acestei probleme consta in impartirea textului citit din fisier in blocuri de cate n caractere, pentru a le putea inmulti cu matricea de codificare. Textul va fi citit cu fgetl, iar in cazul in care este caracter(intre a si z), va fi convertit la ASCII, rezultand un numar din care se va scadea 96. Celelalte cazuri(', . si space) vor fi tratate separat. Citind din fisier cu fscanf, matricea de codificare va fi citita transpus, iar inmultirea cu un bloc de n caractere se va face la stanga (blocul de n caractere va fi un vector linie, care se va inmulti cu matricea de nxn caractere, rezultand tot un vector linie). Dupa aceea, rezultatul va fi stocat, linie cu linie, intr-o alta matrice, pe care se va aplica modulo 29, urmand ca, in final, sa decodific matricea rezultata, adaugand, in mod analog, 96, pentru a obtine numarul ASCII corespunzator unui caracter. Cazurile speciale(apostrof, punct, space) vor fi tratate, din nou, separat.
1B
Mecanismul de transformare a literelor in cifre corespunzatoare este identic cu cel de la 1A. Padding-ul este identic, in sensul ca voi face padding la final, ca sa pot codifica cate n caractere o data. Se calculeaza inversa modulo 29 a matricei de codificare, urmand ca apoi totul sa decurga similar cu punctul 1A. Voi pune totul intr-o matrice, urmand apoi sa inmultesc aceasta matrice cu matricea de codificare la stanga. Rezultatul va fi transformat modulo 29, urmand etapa de decodificare si de scriere in fisier.
1C
La acest task, am schimbat putin abordarea, in sensul ca voi face padding la finalul fiecarui bloc de 1000 de caractere, pentru a putea folosi, practic, aceeasi matrice de codificare pentru codificarea a exact 1000 de caractere din plain-text. Matricea folosita este o matrice de translatie, ce are dimensiune (n+1)x(n+1) pentru a codifica exact n caractere. Ea se va schimba la fiecare 1000 de pasi prin punerea elementului k+1 pe ultima coloana a matricei, in loc de k. Decodificarea se realizeaza in aceeasi maniera cu punctele precedente, cu mentiunea ca, la punctele precedente, inmultirea se facea la stanga, iar acum la dreapta. In ceea ce priveste calcularea inversei, voi folosi Gauss-Jordan, cu mentiunea ca voi calcula inversul modulo 29 al pivotului, folosind algoritmul lui Euclid extins, urmand ca la finalul unei iteratii, sa aplic modulo 29, din nou, pe matrice.
2
Am ales varianta, dupa parerea mea, mai buna a algoritmului lui Strassen, in sensul ca, padding-ul se face, nu pana la 2^n, ci doar cu o linie si o coloana, in cazul in care dimensiunea matricei nu este para. Dimensiunea matricei va deveni din nou, insa, cea initiala, la finele fiecarui apel recursiv, intrucat memorez, la fiecare apel, dimensiunea lui n. Algoritmul functioneaza recursiv, calculand cele 7 matrici intermediare, formate din 7 inmultiri (in loc de 8, asa cum prevede algoritmul), matricea rezultanta fiind formata din adunari si scaderi intre aceste matrici. Partitionarea se calculeaza recursiv, mergand tot pana la 32x32, asemenea algoritmului lui Strassen. Initial, incercasem o varianta neobisnuita a partionarii, si anume aceea de a imparti matricea in patru blocuri, dar cu primul bloc de dimensiune (n-1)x(n-1), unde n=dimensiunea matricei, iar ultimul bloc de dimensiune 1x1. A fost insa ineficient, asa ca am ales primul bloc de la 1 la m, iar ultimul de la m+1 la n, unde m este jumatatea aproximata a matricei. In momentul in care un bloc din matricea partitionata va ajunge la dimensiunea 32x32, atunci voi aplica o alta inversa, aflata in fisierul myinverse.m, bazata pe metoda Gauss-Jordan. Matricea se va ridica la puterea n in timp logaritmic, cu ajutorul unei functii aflate in fisierul pow.m, matricea actuala fiind ea insasi inmultita cu o alta matrice, ce va fi de forma a^2^k, unde k reprezinta, la un pas, numarul de iteratii efectuate + 1.